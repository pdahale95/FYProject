(iCodeforcesProblem
CodeforcesProblem
p0
(dp1
S'desription'
p2
VE. TOF\u000atime limit per test1 second\u000amemory limit per test256 megabytes\u000ainputstandard input\u000aoutputstandard output\u000aToday Pari gave Arya a cool graph problem. Arya wrote a non-optimal solution for it, because he believes in his ability to optimize non-optimal solutions. In addition to being non-optimal, his code was buggy and he tried a lot to optimize it, so the code also became dirty! He keeps getting Time Limit Exceeds and he is disappointed. Suddenly a bright idea came to his mind!\u000aHere is how his dirty code looks like:\u000a\u000adfs(v)\u000a{\u000a     set count[v] = count[v] + 1\u000a     if(count[v] < 1000)\u000a     {\u000a          foreach u in neighbors[v]\u000a          {\u000a               if(visited[u] is equal to false)\u000a               {\u000a                    dfs(u)\u000a               }\u000a               break\u000a          }\u000a     }\u000a     set visited[v] = true\u000a}\u000a\u000amain()\u000a{\u000a     input the digraph()\u000a     TOF()\u000a     foreach 1<=i<=n\u000a     {\u000a          set count[i] = 0 , visited[i] = false\u000a     }\u000a     foreach 1 <= v <= n\u000a     {\u000a          if(visited[v] is equal to false)\u000a          {\u000a               dfs(v)\u000a          }\u000a     }\u000a     ... // And do something cool and magical but we can't tell you what!\u000a}\u000aHe asks you to write the TOF function in order to optimize the running time of the code with minimizing the number of calls of the dfs function. The input is a directed graph and in the TOF function you have to rearrange the edges of the graph in the list neighbors for each vertex. The number of calls of dfs function depends on the arrangement of neighbors of each vertex.\u000aInput\u000aThe first line of the input contains two integers n and m (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u20095000) \u2014 the number of vertices and then number of directed edges in the input graph.\u000aEach of the next m lines contains a pair of integers ui and vi (1\u2009\u2009\u2264\u2009\u2009ui,\u2009\u2009vi\u2009\u2009\u2264\u2009\u2009n), meaning there is a directed edge in the input graph.\u000aYou may assume that the graph won't contain any self-loops and there is at most one edge between any unordered pair of vertices.\u000aOutput\u000aPrint a single integer \u2014 the minimum possible number of dfs calls that can be achieved with permuting the edges.\u000aExamples\u000ainput\u000a3 3\u000a1 2\u000a2 3\u000a3 1\u000aoutput\u000a2998\u000ainput\u000a6 7\u000a1 2\u000a2 3\u000a3 1\u000a3 4\u000a4 5\u000a5 6\u000a6 4\u000aoutput\u000a3001
p3
sS'problemStatement'
p4
VE. TOF\u000atime limit per test1 second\u000amemory limit per test256 megabytes\u000ainputstandard input\u000aoutputstandard output\u000aToday Pari gave Arya a cool graph problem. Arya wrote a non-optimal solution for it, because he believes in his ability to optimize non-optimal solutions. In addition to being non-optimal, his code was buggy and he tried a lot to optimize it, so the code also became dirty! He keeps getting Time Limit Exceeds and he is disappointed. Suddenly a bright idea came to his mind!\u000aHere is how his dirty code looks like:\u000a\u000adfs(v)\u000a{\u000a     set count[v] = count[v] + 1\u000a     if(count[v] < 1000)\u000a     {\u000a          foreach u in neighbors[v]\u000a          {\u000a               if(visited[u] is equal to false)\u000a               {\u000a                    dfs(u)\u000a               }\u000a               break\u000a          }\u000a     }\u000a     set visited[v] = true\u000a}\u000a\u000amain()\u000a{\u000a     input the digraph()\u000a     TOF()\u000a     foreach 1<=i<=n\u000a     {\u000a          set count[i] = 0 , visited[i] = false\u000a     }\u000a     foreach 1 <= v <= n\u000a     {\u000a          if(visited[v] is equal to false)\u000a          {\u000a               dfs(v)\u000a          }\u000a     }\u000a     ... // And do something cool and magical but we can't tell you what!\u000a}\u000aHe asks you to write the TOF function in order to optimize the running time of the code with minimizing the number of calls of the dfs function. The input is a directed graph and in the TOF function you have to rearrange the edges of the graph in the list neighbors for each vertex. The number of calls of dfs function depends on the arrangement of neighbors of each vertex.\u000aInput\u000aThe first line of the input contains two integers n and m (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u20095000) \u2014 the number of vertices and then number of directed edges in the input graph.\u000aEach of the next m lines contains a pair of integers ui and vi (1\u2009\u2009\u2264\u2009\u2009ui,\u2009\u2009vi\u2009\u2009\u2264\u2009\u2009n), meaning there is a directed edge in the input graph.\u000aYou may assume that the graph won't contain any self-loops and there is at most one edge between any unordered pair of vertices.\u000aOutput\u000aPrint a single integer \u2014 the minimum possible number of dfs calls that can be achieved with permuting the edges.\u000aExamples\u000ainput\u000a3 3\u000a1 2\u000a2 3\u000a3 1\u000aoutput\u000a2998\u000ainput\u000a6 7\u000a1 2\u000a2 3\u000a3 1\u000a3 4\u000a4 5\u000a5 6\u000a6 4\u000aoutput\u000a3001
p5
sS'name'
p6
VE. TOF
p7
sS'tags'
p8
S''
p9
sS'url'
p10
Vhttp://codeforces.com/problemset/problem/687/E
p11
sS'memorylimit'
p12
V256 megabytes
p13
sS'timelimit'
p14
V1 second
p15
sS'problemId'
p16
V687/E
p17
sS'id'
p18
c__builtin__
id
p19
sb.